<html>
	<head>
		<title>How to avoid X'es around point sources in maximum likelihood CMB maps</title>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
			extensions: ["tex2jax.js"],
			jax: ["input/TeX", "output/HTML-CSS"],
			tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
		});
		</script>
		<script type="text/javascript" src="http://folk.uio.no/sigurdkn/mathjax/MathJax.js"></script>
		<style>
			body { max-width: 1200px; margin-left: auto; margin-right: auto; padding-left: 1em; padding-right: 1em; }
			img  { width: 100%; }
			figure { display: block;  margin-left: auto; margin-right: auto; width: 100%; max-width: 40em; border: dashed black 1px; margin: 0.5em; }
			figure.wide { max-width: 75em; }
			table  { table-layout: fixed; width: 100%; }
			table.pix img { image-rendering: optimizeSpeed; }
			h1, h2, h3 { text-align: center; }
			p, figcaption { text-align: justify; }
			figcaption { margin: 0.5em; }
			tr.sub th { font-size: 70%; }
			dfn { font-weight: bold; }
		</style>
	</head>
	<body>
		<h1>How to avoid X'es around point sources in maximum likelihood CMB maps</h1>

		<h2>1. Introduction</h2>
		<p>CMB telescopes map the sky by scanning an array of detectors repeatedly across
		the sky, resulting in a time-series of samples $d$. This process is usually
		modeled via the linear equation</p>
		\begin{align}
		d &= Pm + n \label{eq:model} \tag{1}
		\end{align}
		<p>where $d$ is the vector of samples,
		$m$ is a vector representing the pixels of the sky we are trying to reconstruct, and
		$P$ is a response matrix that encodes where the telescope was pointing on the sky
		when each sample was taken and how it responded to that. $n$ represents the
		noise contribution to each sample, and is usually taken to be normal distributed
		with some covariance $N$. The maximum likelihood solution to this equation is</p>
		\begin{align}
		\hat m &= (P^T N^{-1} P)^{-1} P^T N^{-1} d \label{eq:mapmaking} \tag{2}
		\end{align}
		<p>and it's simple to see that this solution is unbiased by inserting our model for $d$:</p>
		\begin{align}
		\langle \hat m \rangle &= (P^T N^{-1} P)^{-1}P^T N^{-1}(Pm + \overbrace{\langle n \rangle}^{0}) = m
		\end{align}
		<p>Given this result it might be surprising to hear that most maximum-likelihood maps
		made using eq. \ref{eq:mapmaking} are biased to some extent, with the archetypical example
		being lines extending away from bright point sources in the map, often in the shape of an X
		(but this depends on the telescope's scanning pattern). The source of this bias is <em>model
			error</em>: the failure of eq. \ref{eq:mapmaking} to accurately describe the real data; and
		in this paper I will describe the main types of model error in maximum-likelihood mapmaking, simulate their
		effect and investigate several methods for mitigating or eliminating them.</p>

		<h2>2. Sub-pixel structure</h2>
		<p>The most obvious problem with eq. \ref{eq:model} is that it models the sky as a
		finite vector of pixels, which will leave out any signal on scales smaller than the
		pixel spacing. This is exacerbated by the canonical choice of a <em>nearest-neighbor</em> response
		model in $P$. In this model, that the value of each sample is simply given by the value of the
		closest pixel to it, regardless of how far away from the pixel center it is. This results
		in a response matrix with a very simple structure: For each row (representing a sample)
		a single element will be 1 (representing the pixel hit by that sample), and all others
		will be zero.</p>
		<p>Multiplication by a matrix with this structure is simple and efficient.
		Given a map m[ny,nx] and arrays y[nsamp], x[nsamp] containing the x and y pixel coordinates
		of each sample, the forward operation $d = Pm$ can be implemented as</p>
		<pre><code>for i in range(nsamp):
    d[i] = m[round(y[i]),round(x[i])]</code></pre>
		<p>and the transpose operation $m = P^Td$ can be implemented as</p>
		<pre><code>for i in range(nsamp):
    m[round(y[i]),round(x[i])] += d[i]</code></pre>
		<p>However, this simplicity comes at a cost: The signal model implied by this
		response matrix has a constant value inside each pixel and a discontinuous jump
		at the edge of each pixel. This model and the resulting error is illustrated in figure 1.
		</p>
		<figure class=wide>
			<table>
				<tr><th>uncorrelated</th><th>correlated</th></tr>
				<tr>
					<td><img src=examples/src_1d_uncorr_tod_log.svg></td>
					<td><img src=examples/src_1d_corr_tod_log.svg></td>
				</tr>
			</table>
			<figcaption>
				<dfn>Figure 1</dfn>: A simulated data vector consisting of a noiseless scan through a smooth, gaussian profile,
				compared to its nearest-neighbor-pixellated maximum likelihood
				model. <dfn>Left</dfn>: When an uncorrelated noise model is used ($N \propto I$)
				the residual is large but stay in the pixel where they were sourced. This error can
				be characterized as a simple pixel window. <dfn>Right</dfn>: When a correlated noise
				model is used the residuals are still large, but are now spread out over a larger area
				than the signal that sourced them.
			</figcaption>
		</figure>
		<p>A step-function model like this clearly cannot match the smooth behavior of the beam-convolved
		sky, and the only term in eq. \ref{eq:model} that can absorb such a mismatch between the data
		and the model is the noise term $n$. How this model error manifests is therefore determined by
		our noise model $N$.</p>
		<p>If $N$ is assumed to be uncorrelated ($N$ diagonal in time domain), then a high value of the residual
		(honorary noise as far as our data model is concerned) in one sample does not tell us
		anything about what the noise is doing in any other samples, and so the residual
		just stays in the pixel that birthed it. The value in each pixel is therefore just
		the mean of the samples that hit it (left panel of figure 1).
		This is approximately
		the mean value of the signal inside the area covered by the pixel, which is a straightforward
		and useful thing to measure, and is not the sort of bias we are worried about here.</p>
		<p>If, on the other hand, $N$ is assumed to be correlated, then the presence of high
		"noise" (actually residual) in some samples
		will make it more likely that other samples within a noise correlation length will
		have a similar value for the noise. For long correlation lengths this could affect samples
		many pixels away from the source of the residual. This is illustrated in the right panel
		of figure 1. Here large sub-pixel residuals in the center result in a non-zero expectation
		value for the noise at large distances. Given that the data has negligibly small values
		there, the best fit model must cancel the expected noise, resulting in a non-zero model
		extending far beyond the area with significant signal.</p>

		<h3>2.1. Higher-order mapmaking</h3>
		<p>Since the largest source of sub-pixel bias is the use of nearest-neighbor interpolation in
		the response matrix $P$, the obvious next step is to use a smoother interpolation function,
		such as bilinear and bicubic spline interpolation. These are popular in image processing, but
		are as far as I am aware unused in CMB map making.</p>
		<p>Bilinear interpolation is considerably slower and more complicated than nearest neighbor,
		and each sample now interacts with the four closest pixels instead of just one.
		The forward operation $d=Pm$ is now:</p>
<pre><code>for i in range(nsamp):
    py1, py2 = floor(y[i]), ceil(y[i])
    px1, px2 = floor(x[i]), ceil(x[i])
    ry,  rx  = y[i]-py1, x[i]-px1
    vx1 = m[py1,px1] * (1-rx) + m[py1,px2] * rx
    vx2 = m[py2,px1] * (1-rx) + m[py2,px2] * rx
    d[i] = vx1 * (1-ry) + vx2 * ry</code></pre>
		<p>The transpose operation $m=P^Td$ is:</p>
<pre><code>for i in range(nsamp):
    py1, py2 = floor(y[i]), ceil(y[i])
    px1, px2 = floor(x[i]), ceil(x[i])
    ry,  rx  = y[i]-py1, x[i]-px1
    vx1 = d[i] * (1-ry)
    vx2 = d[i] * ry
    m[py1,px1] += vx1 * (1-rx)
    m[py1,px2] += vx1 * rx
    m[py2,px1] += vx2 * (1-rx)
    m[py2,px2] += vx2 * rx</code></pre>
		<p>Bicubic spline interpolation is another large step up in complexity. See the appendix for details.</p>
		<p>Figure 2 shows how these higher-order interpolation schemes perform for the same
		1D gaussian simulation we considered in figure 1.</p>
		<figure class=wide>
			<img src=examples/src_1d_highorder.svg></td>
			<figcaption>
				<dfn>Figure 2</dfn>: Comparison of the maximum-likelihood models for nearest neighbor,
				linear and cubic interpolation in the response matrix for uncorrelated and correlated
				noise models, for the same data as in figure 1. Linear and cubic interpolation fit the
				central part of the profile much better than nearest neigbor, leading to lower discrepancy
				between the data and model at high radius in the correlated case (solid curves).
				But this situation is reversed for the uncorrelated
				noise model (dashed curves). This happens because the linear and cubic models are inherently non-local,
				and are willing to sacrifice accuracy in areas where the signal is very weak in order to
				get a better match in areas with strong signal.
			</figcaption>
		</figure>
		<p>Both linear and cubic interpolation fit the peak of the gaussian much better than nearest neighbor,
		resulting in roughly 4 orders of magnitude lower spurious signal at high radius for the case with
		a correlated noise model. However, they only reach this level at large radii. Before this, the
		spurious signal is dominated by a new effect that was not present for nearest neighbor interpolation:
		Higher order interpolation is inherently non-local, which means that each pixel is correlated with
		its neighbors (and neighbors-neighbors for bicubic). This is responsible for the exponentially
		decaying ringing pattern we see in the figure for these interpolation types, even for uncorrelated noise.
		Effectively the fit is sacrificing accuracy at large radius in order to fit the strong, central
		peak slightly better.</p>
		<p>So we see that high interpolation order has smaller total residuals and hence lower
		non-local artifacts from the noise correlations, but low-order interpolation has shorter
		correlation length for the interpolation functions themselves, leading to a faster decay of
		the ringing. For the example in figure 2, the sweet spot is linear interpolation.</p>
		<p>Even better locality (at even higher cost) should be possible with an interpolation
		function based on the actual point spread function of the instrument (cite wandelt here?).
		However, there are diminishing returns when reducing sub-pixel errors because there is another
		class of model errors that if often much larger, as we shall see in section 3.</p>

		<h3>2.2. Point source subtraction</h3>
		<p>In figure 1 we saw that non-local sub-pixel artifacts could extend far away from the
		signal that sourced them, but it also bears noting that their amplitude was about
		$10^4$ times lower than the source. For a smooth, low-contrast signal like the
		cosmic microwave background, each pixel is contaminated by non-local artifacts from
		other pixels in the vincinity, but since those other pixels have signal of similar
		amplitude but random phase, one can expect each pixel to only be contaminated at the
		$10^{-4}$ level, which is negligible. Non-local model errors are therefore only
		a concern when a strong, compact signal is close to a region of weaker signal. In
		CMB map-making the typical case would be a strong point source like a quasar.</p>
		<p>High-order interpolation treats the whole sky the same, and has the advantage that it
		can be done blindly, with no prior knowledge about which parts of the sky might
		be important sources of non-local artifacts. This comes at a large performance
		penalty, however. And as we have seen, the most acessible such methods, linear and and cubic spline
		interpolation, do not perfectly eliminate this bias.</p>
		<p>If one does know the location
		and amplitude of the bright point sources in the sky, however, a much simpler approach
		is to simply subtract those point sources in the data before making the map. This
		results in a map free of both the point sources (which can be useful in itself)
		and the artifacts they would have sourced. If needed, the source model can then be
		projected onto the sky using an uncorrelated noise model $W$ (for example $W=I$)
		and added back to the map.
		\begin{align}
		\hat m_\textrm{srcfree} &= (P^TN^{-1}P)^{-1}P^TN^{-1}(d - \sum_i A_i B_i) \\
		\hat m_\textrm{tot} &= \hat m_\textrm{srcfree} + (P^TW^{-1}P)^{-1}P^T W^{-1}\sum_i A_i B_i
		\end{align}
		Here $A_i$ is the amplitude of source $i$, and $B_i$ is a vector of each sample's
		response to an instrument beam centered on the position of that source. Cite
		something.
		</p>

		<h2>3. Inconsistency</h2>
		<p>Real telescopes don't have 100% accurate pointing and gain, and even if they did, the
		sky is not static and unchanging. These effects mean the telescope effectively sees the
		sky jitter around slightly while varying in brightness. There is no room for this in
		eq. \ref{eq:model} aside from the noise term $n$, so time-variable instrumental errors
		lead to exactly the same sort of non-local model errors as
		sub-pixel errors do. But since these errors are not sourced by sub-pixel structures,
		neither higher-order interpolation nor point source subtraction help here.</p>
		<p>The non-local artifacts are ultimately caused by two factors:</p>
		<ol>
			<li>Multiple samples are mapped onto the same pixel, but don't agree on what that
				pixel should be.</li>
			<li>The correlated noise model causes a non-local response to such errors.</li>
		</ol>
		<p>This points to two approaches for eliminating the artifacts: Model the noise as
		uncorrelated, or add more degrees of freedom.</p>

		<h3>3.1. White source mapping</h3>
		<p>Of course, simply mapping using an uncorrelated noise model would produce a horribly stripy
		map in the presence of
		realistic correlated noise. However, we don't need everything to be uncorrelated to get
		rid of the artifacts, we just need to decouple the bright point sources from those correlations.
		This suggests the following approach:</p>
		<ol>
			<li>Make a point source free set of samples $d'$ from by smoothly inpainting the samples in $d$
				that hit the bright sources, ideally using maximum likelihood inpainting, but the quality of the
				inpainting only matters for the optimality of the method - bad inpainting will not cause a bias.</li>
			<li>Make a maximum-likelihood map $\hat m'$ of the inpainted tod using the full noise model.
				\begin{align}
				\hat m' &= (P^TN^{-1}P)^{-1}P^T N^{-1} d'
				\end{align}
			</li>
			<li>If the inpainted regions were small compared to the noise correlation length, then
				the missing signal $d-d'$ from the previous map will have approximately white noise,
				so we can map these bothersome samples using a simple white noise model:
				\begin{align}
				\Delta m &= (P^TW^{-1}P)^{-1}P^T W^{-1}(d-d')
				\end{align}
			</li>
			<li>Add these maps to get the total, unbiased sky map: $\hat m = \hat m' + \Delta m$.</li>
		</ol>
		
		<h3>3.2. Source sub-sampling</h3>
		<p>We can eliminate model error by having at least one degree of freedom per sample,
		but if we did that to every sample, there would be no averaging down of the noise,
		and we wouldn't really get a map, just a reorganized version of the input data. However,
		there is nothing wrong with oversampling like this just around strong point sources and
		other problematic regions, as long as these regions are small compared to the noise
		correlation length. This results in the model
		\begin{align}
		d &= Pm + Gs + n \\
			&= \begin{bmatrix}P&G\end{bmatrix}\begin{bmatrix}m&s\end{bmatrix}^T + n \tag{3} \label{eq:joint}
		\end{align}
		Here $s$ are the new per-sample degrees of freedom for the samples that hit bright sources,
		and $G$ the matrix that maps them 1-to-1 only the corresponding samples. To be explicit,
		$a=Gs$ could be implemented as <code>a[mask] = s</code>, and $b=G^Td$ as <code>b = d[mask]</code>,
		where mask is True for samples that hit bright sources and False otherwise.</p>
		<p>One can then solve jointly for the maximum-likelihood values $\hat m$ and $\hat s$. This can still
		be done using equation \ref{eq:mapmaking}, since equation \ref{eq:joint} is still of the same form
		as equation \ref{eq:model}. $m$ and $s$ are in isolation not well defined. Some samples are
		both covered by pixels from $m$ and by special per-sample degrees of freedom from $m$, so
		signal can move freely from one to the other without changing the residuals. This can be avoided by
		modifying $P$ to have it skip those samples, but it is not actually necessary, for
		the total map
		\begin{align}
		\hat m_\textrm{tot}&= \hat m + (P^TW^{-1}P)^{-1}P^TW^{-1}\hat s
		\end{align}
		<em>is</em> well-defined in either case, and is the artifact-free map of the sky we are after.</p>
		<p>An advantage of this method is that it is very similar to a common way to handle
		per-sample cuts in maximum-likelihood map-making. There one also solves for an extra degree
		of freedom per cut sample. The only difference is that we here don't throw that part of the
		solution away afterwards, but instead project them back into the final map using a white noise model.
		cite something here too</p>

		<h2>4. Simulations</h2>
		<h2>5. Results</h2>

		<figure class=wide>
			<table class=pix>
				<tr>
					<th></th>
					<th>standard</th>
					<th>standard</th>
					<th>it.lin</th>
					<th>it.cubic</th>
					<th>bilin</th>
					<th>bicubic</th>
					<th>srcwhite</th>
					<th>srcsamp</th>
				</tr>
				<tr class=sub>
					<th></th>
					<th>uncorr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
				</tr>
				<tr>
					<th>plain</th>
					<td><img src=examples/src_2d_uncorr_map_0.png></td>
					<td><img src=examples/src_2d_corr_map_0.png></td>
					<td><img src=examples/src_2d_corr_itlin_map_0.png></td>
					<td><img src=examples/src_2d_corr_itcubic_map_0.png></td>
					<td><img src=examples/src_2d_corr_lin_map_0.png></td>
					<td><img src=examples/src_2d_corr_cubic_map_0.png></td>
					<td><img src=examples/src_2d_corr_srcwhite_map_0.png></td>
					<td><img src=examples/src_2d_corr_srcsamp_map_0.png></td>
				</tr>
				<tr>
					<th>gain error</th>
					<td><img src=examples/src_gain_2d_uncorr_map_0.png></td>
					<td><img src=examples/src_gain_2d_corr_map_0.png></td>
					<td><img src=examples/src_gain_2d_corr_itlin_map_0.png></td>
					<td><img src=examples/src_gain_2d_corr_itcubic_map_0.png></td>
					<td><img src=examples/src_gain_2d_corr_lin_map_0.png></td>
					<td><img src=examples/src_gain_2d_corr_cubic_map_0.png></td>
					<td><img src=examples/src_gain_2d_corr_srcwhite_map_0.png></td>
					<td><img src=examples/src_gain_2d_corr_srcsamp_map_0.png></td>
				</tr>
				<tr>
					<th>pt. error</th>
					<td><img src=examples/src_ptoff_2d_uncorr_map_0.png></td>
					<td><img src=examples/src_ptoff_2d_corr_map_0.png></td>
					<td><img src=examples/src_ptoff_2d_corr_itlin_map_0.png></td>
					<td><img src=examples/src_ptoff_2d_corr_itcubic_map_0.png></td>
					<td><img src=examples/src_ptoff_2d_corr_lin_map_0.png></td>
					<td><img src=examples/src_ptoff_2d_corr_cubic_map_0.png></td>
					<td><img src=examples/src_ptoff_2d_corr_srcwhite_map_0.png></td>
					<td><img src=examples/src_ptoff_2d_corr_srcsamp_map_0.png></td>
				</tr>
				<tr>
					<th>plain + noise</th>
					<td><img src=examples/src_noise_2d_uncorr_map_0.png></td>
					<td><img src=examples/src_noise_2d_corr_map_0.png></td>
					<td><img src=examples/src_noise_2d_corr_itlin_map_0.png></td>
					<td><img src=examples/src_noise_2d_corr_itcubic_map_0.png></td>
					<td><img src=examples/src_noise_2d_corr_lin_map_0.png></td>
					<td><img src=examples/src_noise_2d_corr_cubic_map_0.png></td>
					<td><img src=examples/src_noise_2d_corr_srcwhite_map_0.png></td>
					<td><img src=examples/src_noise_2d_corr_srcsamp_map_0.png></td>
				</tr>
				<tr>
					<th>gain error + noise</th>
					<td><img src=examples/src_noise_gain_2d_uncorr_map_0.png></td>
					<td><img src=examples/src_noise_gain_2d_corr_map_0.png></td>
					<td><img src=examples/src_noise_gain_2d_corr_itlin_map_0.png></td>
					<td><img src=examples/src_noise_gain_2d_corr_itcubic_map_0.png></td>
					<td><img src=examples/src_noise_gain_2d_corr_lin_map_0.png></td>
					<td><img src=examples/src_noise_gain_2d_corr_cubic_map_0.png></td>
					<td><img src=examples/src_noise_gain_2d_corr_srcwhite_map_0.png></td>
					<td><img src=examples/src_noise_gain_2d_corr_srcsamp_map_0.png></td>
				</tr>
				<tr>
					<th>pt. error + noise</th>
					<td><img src=examples/src_noise_ptoff_2d_uncorr_map_0.png></td>
					<td><img src=examples/src_noise_ptoff_2d_corr_map_0.png></td>
					<td><img src=examples/src_noise_ptoff_2d_corr_itlin_map_0.png></td>
					<td><img src=examples/src_noise_ptoff_2d_corr_itcubic_map_0.png></td>
					<td><img src=examples/src_noise_ptoff_2d_corr_lin_map_0.png></td>
					<td><img src=examples/src_noise_ptoff_2d_corr_cubic_map_0.png></td>
					<td><img src=examples/src_noise_ptoff_2d_corr_srcwhite_map_0.png></td>
					<td><img src=examples/src_noise_ptoff_2d_corr_srcsamp_map_0.png></td>
				</tr>
			</table>
			<figcaption>
				<p><dfn>Figure 3</dfn>: Model errors around a bright point source for the
				different methods discussed in this paper, for a simulation with 3x3
				samples uniformly distributed inside each pixel for each of a vertical and
				horizontal scanning pattern. The top half is for a noise free
				simulation, while the bottom half includes strongly correlated noise.
				The rows are: <dfn>plain</dfn>: no special conditions; <dfn>gain error</dfn>:
				the vertical scanning pattern sees a 1% higher signal than the horizontal
				scanning pattern; and <dfn>pt. error</dfn>: the horizontal scanning pattern
				sees the signal offset by 0.01 pixel diagonally. The column headers refer to
				the different mapmaking algorithms described in the text. The subheaders
				indicate whether a correlated or uncorrelated noise model was used. The
				color range is &pm;$10^{-4}$ of the peak source amplitude.</p>
				<!--<p>Standard nearest neighbor mapmaking results in a prominent X-shaped
				subpixel errors
				following the scanning directions as soon as we turn on correlations in the
				noise model. With the exception of the bicubic method, the position-independent
				methods only modestly reduce these errors. Bicubic mapmaking greatly reduces
				the long-distance errors, but introduces some short-distance ringing as the
				spline sacrifices fidelity at the edge of the source to match the strong signal
				at its center as closely as possible. None of these position-independent methods
				help noticeably against non-local bias from gain and pointing errors.</p>-->
			</figcaption>
		</figure>

		<figure class=wide>
			<table class=pix>
				<tr>
					<th></th>
					<th>standard</th>
					<th>standard</th>
					<th>it.lin</th>
					<th>it.cubic</th>
					<th>bilin</th>
					<th>bicubic</th>
					<th>srcwhite</th>
					<th>srcsamp</th>
				</tr>
				<tr class=sub>
					<th></th>
					<th>uncorr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
					<th>corr</th>
				</tr>
				<tr>
					<th>plain</th>
					<td><img src=examples/cmb_2d_uncorr_map_0.png></td>
					<td><img src=examples/cmb_2d_corr_map_0.png></td>
					<td><img src=examples/cmb_2d_corr_itlin_map_0.png></td>
					<td><img src=examples/cmb_2d_corr_itcubic_map_0.png></td>
					<td><img src=examples/cmb_2d_corr_lin_map_0.png></td>
					<td><img src=examples/cmb_2d_corr_cubic_map_0.png></td>
					<td><img src=examples/cmb_2d_corr_srcwhite_map_0.png></td>
					<td><img src=examples/cmb_2d_corr_srcsamp_map_0.png></td>
				</tr>
				<tr>
					<th>gain error</th>
					<td><img src=examples/cmb_gain_2d_uncorr_map_0.png></td>
					<td><img src=examples/cmb_gain_2d_corr_map_0.png></td>
					<td><img src=examples/cmb_gain_2d_corr_itlin_map_0.png></td>
					<td><img src=examples/cmb_gain_2d_corr_itcubic_map_0.png></td>
					<td><img src=examples/cmb_gain_2d_corr_lin_map_0.png></td>
					<td><img src=examples/cmb_gain_2d_corr_cubic_map_0.png></td>
					<td><img src=examples/cmb_gain_2d_corr_srcwhite_map_0.png></td>
					<td><img src=examples/cmb_gain_2d_corr_srcsamp_map_0.png></td>
				</tr>
				<tr>
					<th>pt. error</th>
					<td><img src=examples/cmb_ptoff_2d_uncorr_map_0.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_map_0.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_itlin_map_0.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_itcubic_map_0.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_lin_map_0.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_cubic_map_0.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_srcwhite_map_0.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_srcsamp_map_0.png></td>
				</tr>
				<tr>
					<th>plain resid</th>
					<td><img src=examples/cmb_2d_uncorr_map_1.png></td>
					<td><img src=examples/cmb_2d_corr_map_1.png></td>
					<td><img src=examples/cmb_2d_corr_itlin_map_1.png></td>
					<td><img src=examples/cmb_2d_corr_itcubic_map_1.png></td>
					<td><img src=examples/cmb_2d_corr_lin_map_1.png></td>
					<td><img src=examples/cmb_2d_corr_cubic_map_1.png></td>
					<td><img src=examples/cmb_2d_corr_srcwhite_map_1.png></td>
					<td><img src=examples/cmb_2d_corr_srcsamp_map_1.png></td>
				</tr>
				<tr>
					<th>gain error resid</th>
					<td><img src=examples/cmb_gain_2d_uncorr_map_1.png></td>
					<td><img src=examples/cmb_gain_2d_corr_map_1.png></td>
					<td><img src=examples/cmb_gain_2d_corr_itlin_map_1.png></td>
					<td><img src=examples/cmb_gain_2d_corr_itcubic_map_1.png></td>
					<td><img src=examples/cmb_gain_2d_corr_lin_map_1.png></td>
					<td><img src=examples/cmb_gain_2d_corr_cubic_map_1.png></td>
					<td><img src=examples/cmb_gain_2d_corr_srcwhite_map_1.png></td>
					<td><img src=examples/cmb_gain_2d_corr_srcsamp_map_1.png></td>
				</tr>
				<tr>
					<th>pt. error resid</th>
					<td><img src=examples/cmb_ptoff_2d_uncorr_map_1.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_map_1.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_itlin_map_1.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_itcubic_map_1.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_lin_map_1.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_cubic_map_1.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_srcwhite_map_1.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_srcsamp_map_1.png></td>
				</tr>
				<tr>
					<th>plain wdiff</th>
					<td><img src=examples/cmb_2d_uncorr_map_2.png></td>
					<td><img src=examples/cmb_2d_corr_map_2.png></td>
					<td><img src=examples/cmb_2d_corr_itlin_map_2.png></td>
					<td><img src=examples/cmb_2d_corr_itcubic_map_2.png></td>
					<td><img src=examples/cmb_2d_corr_lin_map_2.png></td>
					<td><img src=examples/cmb_2d_corr_cubic_map_2.png></td>
					<td><img src=examples/cmb_2d_corr_srcwhite_map_2.png></td>
					<td><img src=examples/cmb_2d_corr_srcsamp_map_2.png></td>
				</tr>
				<tr>
					<th>gain error wdiff</th>
					<td><img src=examples/cmb_gain_2d_uncorr_map_2.png></td>
					<td><img src=examples/cmb_gain_2d_corr_map_2.png></td>
					<td><img src=examples/cmb_gain_2d_corr_itlin_map_2.png></td>
					<td><img src=examples/cmb_gain_2d_corr_itcubic_map_2.png></td>
					<td><img src=examples/cmb_gain_2d_corr_lin_map_2.png></td>
					<td><img src=examples/cmb_gain_2d_corr_cubic_map_2.png></td>
					<td><img src=examples/cmb_gain_2d_corr_srcwhite_map_2.png></td>
					<td><img src=examples/cmb_gain_2d_corr_srcsamp_map_2.png></td>
				</tr>
				<tr>
					<th>pt. error wdiff</th>
					<td><img src=examples/cmb_ptoff_2d_uncorr_map_2.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_map_2.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_itlin_map_2.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_itcubic_map_2.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_lin_map_2.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_cubic_map_2.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_srcwhite_map_2.png></td>
					<td><img src=examples/cmb_ptoff_2d_corr_srcsamp_map_2.png></td>
				</tr>
			</table>
			<figcaption>
				<dfn>Figure 4</dfn>: Like figure 2, but for a noiseless CMB-like signal instead of
				a strong point source. <dfn>Top:</dfn> the resulting maps. <dfn>Middle</dfn>:
				the root-mean-square of the residual (data-model) per pixel. <dfn>Bottom</dfn>:
				The difference between each map and the standard uncorrelated case. The color
				range is &pm;4 in arbitrary units at the top and &pm;0.1 in the same units in
				the middle and bottom. The small gain and pointing errors we simulate here have
				almost no effect for low dynamic range fields like the CMB.
			</figcaption>
		</figure>

		<h2>Technical</h2>
		<h3>Nearest neighbor P</h3>
		<p>Given a map m[ny,nx] and arrays y[nsamp], x[nsamp] containing the x and y pixel coordinates
		of each sample, the forward operation $a = Pm$ can be implemented as <pre><code>for i in range(nsamp):
    a[i] = m[round(y[i]),round(x[i])]</code></pre>
		and the backward operation $b = P^Td$ can be implemented as <pre><code>for i in range(nsamp):
    b[round(y[i]),round(x[i])] += d[i]</code></pre>
		<h3>Bilinear P</h3>
		<p>The forward operation now depends on the 4 pixels closest to each point.</p>
<pre><code>for i in range(nsamp):
    py1, py2 = floor(y[i]), ceil(y[i])
    px1, px2 = floor(x[i]), ceil(x[i])
    ry,  rx  = y[i]-py1, x[i]-px1
    vx1 = m[py1,px1] * (1-rx) + m[py1,px2] * rx
    vx2 = m[py2,px1] * (1-rx) + m[py2,px2] * rx
    a[i] = vx1 * (1-ry) + vx2 * ry</code></pre>
		<p>The backward operation is:</p>
<pre><code>for i in range(nsamp):
    py1, py2 = floor(y[i]), ceil(y[i])
    px1, px2 = floor(x[i]), ceil(x[i])
    ry,  rx  = y[i]-py1, x[i]-px1
    vx1 = a[i] * (1-ry)
    vx2 = a[i] * ry
    m[py1,px1] += vx1 * (1-rx)
    m[py1,px2] += vx1 * rx
    m[py2,px1] += vx2 * (1-rx)
    m[py2,px2] += vx2 * rx</code></pre>
		<h3>Bicubic P</h3>
		<p>This one is pretty complicated. Should we leave it out and only refer to pixell.interpolate?
		On the other hand it might be useful for someone.</p>
	</body>
</html>
